# -*- coding: utf-8 -*-
"""CV_Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HmwR9fIggiwqT-H9du9XUqSodz2_FLx4
"""

!pip install -q tensorflow==2.3.1
!pip install -q tensorflow-quantum

# Commented out IPython magic to ensure Python compatibility.
import tensorflow as tf      # the tensorflow and tensorflow quantum library are being imported. The tensorflow quantum library is used to simulate 
import tensorflow_quantum as tfq

import cirq
import sympy
import numpy as np
import seaborn as sns
import collections

from google.colab import drive
import cv2

# visualization tools
# %matplotlib inline
import matplotlib.pyplot as plt
from cirq.contrib.svg import SVGCircuit

drive.mount('/content/drive/')

import pandas as pd
#mount the drive
labels_df = pd.read_csv('/content/drive/Shareddrives/CV/Data/train_label.csv')
# labels_df.head()

#one hot encoding for the multi label
from itertools import chain
labels_list = list(chain.from_iterable([tags.split(" ") for tags in labels_df['tags'].values]))
labels_set = set(labels_list)
for c_label in labels_set:
    labels_df[c_label] = labels_df['tags'].map(lambda finding: 1 if c_label in finding else 0)
df=labels_df

#filtering primary labels from entire dataset
df_0=df[df['primary']==0]
# df_0.info()
df_0 = df_0[['image_name','primary']]

#filtering non primary labels from entire dataset
df_1=df[df['primary']==1]
df_1 = df_1[['image_name','primary']]

#appending primary and non primary labels into two sets of data frame of train and test


df_1_tr=df_1[0:1200]
df_1_t=df_1[1000:1543]
df_0_tr=df_0[0:1000]
df_0_t=df_0[1000:1457]
df_train= df_1_tr.append(df_0_tr)
df_test= df_1_t.append(df_0_t)

#shuffling train and test dataset so they will have evenly disturbuted primary and non primary
df_train= df_train.sample(frac=1).reset_index(drop=True)
df_test= df_test.sample(frac=1).reset_index(drop=True)

#converting label coloumn to arrays
train_labels= df_train["primary"].to_numpy()
test_labels= df_test["primary"].to_numpy()

#image names into series
train_images= df_train['image_name']
test_images= df_test['image_name']

train_images

n=2200
x_trainData = []
for i in range(n):
  name=train_images[i]
  img=cv2.imread("/content/drive/MyDrive/Data/train_colab/{}".format(name))
  print(i)
  img = np.asarray(img, dtype=np.uint8)
  gray = cv2. cvtColor(img, cv2.COLOR_BGR2GRAY)
  gray = np.expand_dims(gray, 2)
  x_trainData.append(gray)
x_t = np.array(x_trainData)

n=1000
x_testData = []
for i in range(0,n):
  print(i)
  name=test_images[i]
  img=cv2.imread("/content/drive/MyDrive/Data/train_colab/{}".format(name))
  img = np.array(img, dtype=np.uint8)
  gray = cv2. cvtColor(img, cv2.COLOR_BGR2GRAY)
  gray = np.expand_dims(gray, 2)
  x_testData.append(gray)
x_tes = np.array(x_testData)

# print(x_t.shape)
# print(x_tes.shape)

x_train_small = tf.image.resize(x_t, (4,4)).numpy()
# x_train_small.shape

x_test_small = tf.image.resize(x_tes, (4,4)).numpy()
# x_test_small.shape

y_t = np.array(train_labels[0:2200])
y_tes = np.array(test_labels[0:1000])

THRESHOLD = 0.5

x_train_bin = np.array(x_train_small > THRESHOLD, dtype=np.float32)
x_test_bin = np.array(x_test_small > THRESHOLD, dtype=np.float32)

# code snippet to convert classical data to quantuzwd data. 
# the model in quantum machine learning is refered to as circuit

def convert_to_circuit(image):
    """Encode truncated classical image into quantum datapoint."""
    values = np.ndarray.flatten(image)
    qubits = cirq.GridQubit.rect(4, 4)
    circuit = cirq.Circuit()
    for i, value in enumerate(values):
        if value:
            circuit.append(cirq.X(qubits[i]))
    return circuit


x_train_circ = [convert_to_circuit(x) for x in x_train_bin]
x_test_circ = [convert_to_circuit(x) for x in x_test_bin]

bin_img = x_train_bin[0,:,:,0]
indices = np.array(np.where(bin_img)).T
indices

# converting training and testing set to tensors to pass them in the fit function below
x_train_tfcirc = tfq.convert_to_tensor(x_train_circ)
x_test_tfcirc = tfq.convert_to_tensor(x_test_circ)

# Building circuit using qubits, circuits and gates
class CircuitLayerBuilder():
    def __init__(self, data_qubits, readout):
        self.data_qubits = data_qubits
        self.readout = readout

    def add_layer(self, circuit, gate, prefix):
        for i, qubit in enumerate(self.data_qubits):
            symbol = sympy.Symbol(prefix + '-' + str(i))
            circuit.append(gate(qubit, self.readout)**symbol)

# creating quantum model 

def create_quantum_model():
 
    data_qubits = cirq.GridQubit.rect(4, 4)  # a 4x4 grid.
    readout = cirq.GridQubit(-1, -1)         # a single qubit at [-1,-1]
    circuit = cirq.Circuit()
    # Prepare the readout qubit.
    circuit.append(cirq.X(readout))
    circuit.append(cirq.H(readout))
    model_builder = CircuitLayerBuilder(
        data_qubits = data_qubits,
        readout=readout)
    # Adding layers
    model_builder.add_layer(circuit, cirq.XX, "xx1")
    model_builder.add_layer(circuit, cirq.ZZ, "zz1")


    #Readout qubit.
    circuit.append(cirq.H(readout))
    return circuit, cirq.Z(readout)

model_circuit, model_readout = create_quantum_model()

# Build the Keras model.
model = tf.keras.Sequential([
    # The input is the data-circuit, encoded as a tf.string
    tf.keras.layers.Input(shape=(), dtype=tf.string),
    # The PQC layer returns the expected value of the readout gate, range [-1,1].
    tfq.layers.PQC(model_circuit, model_readout),
])

y_train_hinge = 2.0*y_t-1.0
y_test_hinge = 2.0*y_tes-1.0

def hinge_accuracy(y_true, y_pred):
    y_true = tf.squeeze(y_true) > 0.0
    y_pred = tf.squeeze(y_pred) > 0.0
    result = tf.cast(y_true == y_pred, tf.float32)

    return tf.reduce_mean(result)

model.compile(
    loss=tf.keras.losses.Hinge(),
    optimizer=tf.keras.optimizers.Adam(),
    metrics=[hinge_accuracy])

print(model.summary())


NUM_EXAMPLES = len(x_train_tfcirc)
NUM_EXAMPLES

x_train_tfcirc_sub = x_train_tfcirc[:NUM_EXAMPLES]
y_train_hinge_sub = y_train_hinge[:NUM_EXAMPLES]

EPOCHS = 5
qnn_history = model.fit(
      x_train_tfcirc_sub, y_train_hinge_sub,
      batch_size=100,
      epochs=EPOCHS,
      verbose=1,
      validation_data=(x_test_tfcirc, y_test_hinge))

qnn_results = model.evaluate(x_test_tfcirc, y_tes)

